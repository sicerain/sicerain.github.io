### 原子操作

---

## 乱序执行：out of order

* C++程序并不是我们想象的那样，按照编写的代码顺序，对应为相应的汇编代码顺序执行。C++的程序实际上是乱序执行的。

* **同一线程中，彼此没有依赖关系的指令会被乱序执行。我们重点关心读 写指令，因为它们会产生外部可见的影响。**

  > 同一线程：同一线程内的指令不是按编码顺序执行
  >
  > 没有依赖关系：两次访问了相同的地址，访问了同一个变量，两次访问中有一次写操作，这是有依赖关系.
  >
  > 读写指令：读写指令在cpu内经常发生

  比如以下两条指令的执行顺序完全无法预测：

  ```C++
  x = 1;
  y = 2;
  ```

  但是下面的两条指令存在依赖关系，指令将按照编码顺序执行。

  ```c++
  x = 5; // x = some input value;
  y = x + z;
  /* 两次访问了x变量，先写后读，这两条指令存在依赖关系，指令按编码顺序执行 */
  ```

## 乱序执行原因：

* 编译器优化：**Single-Threaded Optimizations原则 在单线程的情况下**，优化行为（换序），不影响运行结果，就是允许的。

* 处理器：现代处理器运行指令乱序执行，以避免因等待资源而导致处理器处于闲置状态。

  > 为提高cpu性能，处理器处理指令不一定是顺序的，原因在于cpu对L1 cache，L2 cache，memory的读写速率各不相同<!--如果cpu执行一条指令是cycle，那读L1 cache也是1个cycle，读L2cache是2个cycle，读内存数据是100个cycle-->，提高cpu性能的方式之一是减少cache miss，所以可能会对指令的处理顺序做调整。

  ```c++
  /* 处理器顺序执行 */
  y = x; // cache miss,没有立即得到x的值
  z = y + 1; // wait until x get value
  w = m + n; // wait until z get value
  
  /* 处理器乱序执行 */
  y = x; // cache miss,没有立即得到x的值
  w = m + n; // but m,n is ready
  z = y + 1; // then get x
  ```

* 存储系统：store buffer（L1 cache）仅对各个cpu core可见，未写入一致性缓存前（一般是L2 cache）可能导致指令的out of order。

  > 现代cpu为提高自身的处理效率，引入了多级缓存（L1，L2，L3）。在很多系统设计中，不论是软件还是硬件，都引入了缓存，为的是解决i/o读写速度与计算处理速度不同步的问题，这种不同步可能会导致上述所说的因等待资源而导致的计算资源闲置。

  在程序中的各个线程会被多个cpu core处理，这就可能导致不同的cpu core看到的数据不一样，**如果cpu处理生产的数据已经被放置到storebuffer，则说明该数据已经全局可见（对cpu）**

  简单的cpu体系架构：

  <img src="/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210203160317768.png" alt="image-20210203160317768" style="zoom:50%;" />

  store buffer 导致的乱序：

  ![image-20210203160603434](/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210203160603434.png)

  ![image-20210203160620047](/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210203160620047.png)

  ![image-20210203160639583](/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210203160639583.png)

  ![image-20210203160650205](/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210203160650205.png)



## ONE CASE：

Dekker's and peterson's Algorithms

```c++
// thread one
x = 1;
if (y == 0) {
  // critical region code
} else {
  // wait and retry
}

// thread two
y = 1;
if (x == 0) {
  // critical region code
} else {
  // wait and retry
}
```

1.cpu out of order 乱序执行

![image-20210304193439634](/Users/sunbingyu/Library/Application Support/typora-user-images/image-20210304193439634.png)

2. store buffer：见store导致乱序原因

## SC-DRF SC for Data-Race-Free Programs 

> 乱序执行对单线程程序没有影响，但是会影响到多线程程序。
>
> 多线程下，可能写出了标准的互斥代码，但是C++下的乱序执行让结果仍然不可预测。

**SC-DRF定义：C++的承诺，如果程序不存在竞争(race),那么程序运行起来就好像是顺序一致性(Sequential Consistency,     SC)**

> 1. 竞争：两个线程，访问同一个变量【都可以取到内存中这个变量的地址进行修改】（共享变量或者共享资源），其中有一个线程发生写操作。
> 2. 那么，不存在竞争就是说，用某种操作，将全局变量保护起来，或者说将对这个全局变量的读写操作保护起来，例如锁，或者原子指令。
> 3. (对读写操作做出同步，对线程临界区代码加以保护）
> 4. 避免竞争的核心方法是确保在同一个时间内，只有一个（零个）线程，在临界区内。这个方法便是通过锁机制或者原子操作。
> 5. out-of-order 和 SC-DRF有何联系：在out-of-order环境下，是无法实现线程同步的，因为对线程同步的指令需要编译器CPU存储器的相互配合，共同避免竞争的发生（实现原子操作和锁）。

1.乱序执行无法避免。

2.如果读写指令所涉及的变量不是共享变量，乱序执行不会产生坏的影响。

3.单线程环境下，乱序执行不会产生坏的影响。

4如果读写指令所涉及的变量是共享变量，程序员必须告诉编译 器和处理器。告诉的方式就是通过锁或者原子操作。

​           4.1当临界区包含多条指令时，用锁。

​          4.2当临界区只包含一个整数或者指针操作时，用原子变量。
